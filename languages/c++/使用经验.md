***
Exceptional C++
***

##  打印类型信息的方法

- 使用typeid
```cpp
#include <iostream>
#include <typeinfo>

int main() {
    int a = 10;
    double b = 3.14;

    std::cout << "Type of a: " << typeid(a).name() << std::endl;
    std::cout << "Type of b: " << typeid(b).name() << std::endl;

    return 0;
}

```

但是typeid返回的往往是编译器处理过了的类型名字，很可能不是我们想要的结果

- 使用decltype
```cpp
#include <iostream>
#include <type_traits>

template <typename T>
std::string get_type_name() {
    return typeid(T).name();
}

struct Point{
	int x;
	int y;
}tit;
int main() {
    int a = 10;
    double b = 3.14;

    std::cout << "Type of a: " << get_type_name<decltype(a)>() << std::endl;
    std::cout << "Type of b: " << get_type_name<decltype(b)>() << std::endl;
		std::cout <<get_type_name<decltype(tit)>()<<std::endl;
    return 0;
}
```
- 使用编译器扩展： 
一些编译器提供了内置函数或扩展来获取类型的名字。例如，在 GCC 和 Clang 中，可以使用 `__PRETTY_FUNCTION__` 或 `__FUNCTION__` 预定义宏与模板元编程结合，以获取类型的名字。请注意，这些扩展不具有可移植性，可能不适用于所有编译器

```cpp
#include <iostream>
#include <string>
#include <type_traits>

template <typename T>
std::string get_type_name() {
    std::string function_signature = __PRETTY_FUNCTION__;
    std::string prefix = "std::string get_type_name() [T = ";
    std::string suffix = "]";
    std::size_t start = function_signature.find(prefix) + prefix.length();
    std::size_t end = function_signature.rfind(suffix);
    return function_signature.substr(start, end - start);
}

int main() {
    int a = 10;
    double b = 3.14;

    std::cout << "Type of a: " << get_type_name<decltype(a)>() << std::endl;
    std::cout << "Type of b: " << get_type_name<decltype(b)>() << std::endl;

    return 0;
}
```


目前看来，只有方法三可以获得完整的类型名


## 迭代器

1. 当某个迭代器是end()时，它是不可以被解引用的，因此解引用迭代器时要小心
2. 只要不用修改容器元素值，就用cbegin(),cend()
3. 前闭后开的迭代器区间一定要是个有效的范围，不能前面的比后面的小
4. C++不允许对内置类型的临时变量进行修改，如果迭代器的类型是个类的话就无所谓了
		所以像`e.insert(--e.end(),TodayDate()); Date* f(); p = --f();` 之类的代码就很容易报错
4. 只要对vector这类容器进行了insert操作，就一定要默认所有的迭代器均已失效，不要再用了



## 别名

### null,0,nullptr
不要使用null，使用nullptr，因为null有可能被识别为int,也就是0.而不是`void *`,但是nullptr肯定会被识别为`void *
尤其是设计到模板类型推导时
_模板类型推导将_`_0_`_和_`_NULL_`_推导为一个错误的类型（即它们的实际类型，而不是作为空指针的隐含意义），这就导致在当你想要一个空指针时，它们的替代品_`_nullptr_`_很吸引人_


## std::for_each

该函数在algorithm头文件下，可以用来在两个迭代器之间使用一个一元函数，传lambda函数进去相当好用

```cpp
#include<algorithm>
#include<iostream>
#include<vector>

using std::cout;
using std::endl;

struct Sum{
	void operator()(int n){sum+=n;}
	int sum{0};
};

int main(){
	std::vector<int> v{1,2,3,4,5};
	auto print = [](const int n){cout<<n<<endl;};
	std::for_each(v.cbegin(),v.cend(),print);
    std::for_each(v.begin(),v.end(),[](int& n){n++;});
	std::for_each(v.cbegin(),v.cend(),print);
	Sum s = std::for_each(v.cbegin(),v.cend(),Sum());
	cout<<s.sum<<endl;
	return 0;
}
```


## std::mem_fn

在头文件functional 里面

```cpp
#include<functional>
#include<iostream>
#include<memory>

struct Foo{
	void hello(){
		std::cout<<"Hello, world!"<<std::endl;
	}
};


int main(){
	auto f = Foo{};
	auto halo = std::mem_fn(&Foo::hello);
	halo(f);
	return 0;
}
```

1.  使用`std::mem_fn`函数创建一个成员函数包装器（称为`halo`），该包装器用于调用`Foo`类的`hello`成员函数。`std::mem_fn`的参数是`Foo::hello`的指针。
    
2.  调用`halo`成员函数包装器，并将`f`作为参数传递。这相当于调用`f.hello()`。



## 别名的使用

当声明一个函数指针时别名比typedef更好理解

```cpp
//FP是一个指向函数的指针的同义词，它指向的函数带有
//int和const std::string&形参，不返回任何东西
typedef void (*FP)(int, const std::string&);    //typedef

//含义同上
using FP = void (*)(int, const std::string&);   //别名声明
```

别名声明可以被模板化，但是typedef不可以

```cpp
template<typename T>                            //MyAllocList<T>是
using MyAllocList = std::list<T, MyAlloc<T>>;   //std::list<T, MyAlloc<T>>
                                                //的同义词

MyAllocList<Widget> lw;                         //用户代码


template<typename T> 
using MyAllocList = std::list<T, MyAlloc<T>>;   //同之前一样

template<typename T> 
class Widget {
private:
    MyAllocList<T> list;                        //没有“typename”
    …                                           //没有“::type”
};
```

`MyAllocList<T>`看上去是依赖于T的，然而使用了using之后 MyAllocList就是一个别名模板，它肯定是一个类型，所以编译器会将`MyAllocList<T>`视作非依赖类型，从而不需要使用typename修饰符



## 需要将构造函数放进private的场景

1.  **单例模式**：在单例模式中，一个类只允许创建一个实例。将构造函数设为 private 可以防止用户在类外部创建多个实例。在这种情况下，类通常会提供一个静态方法（如 getInstance()），用于获取唯一的实例。
```cpp
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }

    // 禁止拷贝和赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

private:
    Singleton() {}
};
```

2.  **工厂模式**：在工厂模式中，类的实例通过工厂方法创建，而不是通过构造函数直接创建。这可以使得对象创建过程更灵活，例如，根据参数选择要创建的具体子类。将构造函数设置为 private 可以确保对象只能通过工厂方法创建。
```cpp
class Product {
public:
    static std::unique_ptr<Product> createProduct(int type);

private:
    Product() {}
};

std::unique_ptr<Product> Product::createProduct(int type) {
    if (type == 1) {
        return std::make_unique<ConcreteProduct1>();
    } else {
        return std::make_unique<ConcreteProduct2>();
    }
}
```

3.  **防止派生**：如果你希望一个类不能被继承，可以将其构造函数设为 private，并通过友元类来访问构造函数。这种方法在 C++11 之前的版本中比较常见。在 C++11 及以后的版本中，可以使用关键字 `final` 来防止类被继承。
```cpp
class NonDerivable {
    friend class FriendClass;

private:
    NonDerivable() {}
};

class FriendClass {
public:
    void createInstance() {
        NonDerivable obj;
    }
};
```

总之，将构造函数放在 private 访问区域主要用于控制类的实例化方式，以确保符合特定的设计模式或约束


## decltype(auto)

1.  `decltype`：可以根据表达式推导出其类型，包括引用和cv限定符（const/volatile）。
2.  `auto`：根据初始化表达式自动推导类型，但是会忽略引用和cv限定符

使用 `decltype(auto)` 时需要注意一些细节：

1.  当使用 `decltype(auto)` 推导变量类型时，需要确保表达式不是临时变量，否则会导致引用悬挂。
2.  `decltype(auto)` 对于括号表达式非常敏感，因为它们可能改变推导出的类型。例如，使用括号会导致引用类型的推导。


![[Pasted image 20230409180411.png]]


```cpp
#include<iostream>
#include<type_traits> 

using std::cout;
using std::endl;

decltype(auto) get_ref(int x){
	return (x);
}

int main(){
	int i = 42;
	if(std::is_reference<decltype(get_ref(i))>::value){
		cout<<"x is a ref"<<endl;
	}
	return 0;
}
```

## alias

c++引入了using

```cpp
typedef int (*process)(void *);
using NewProcess = int(*)(void *);
template<typename T>
using TrueDarkMagic = MagicType<std::vector<T>, std::string>;

int main() {
    TrueDarkMagic<bool> you;
}
```

## 委托构造delegate constructor

![[Pasted image 20230409182347.png]]

```cpp
#include<iostream>

using std::cout;
using std::endl;
using std::ostream;

class Point{
	int x;
	int y;
public:
	Point():x(3),y(4){}
	Point(int hz) : Point() {
		x = hz;
	}
	friend ostream& operator<<(ostream&, const Point&);
};

ostream& operator<<(ostream& os, const Point& pt){
	os<<pt.x<<endl<<pt.y<<endl;
	return os;
}

int main(){
	Point me = Point(2);
	cout<<me;
	return 0;
}
```

## explicit virtual function overrides

显式虚函数覆写（Explicit Virtual Function Overrides）是 C++11 引入的特性，通过在派生类中使用 `override` 关键字显式声明一个虚函数覆盖（重写）了基类的虚函数。这个特性主要解决了程序员在实现继承和多态时可能遇到的问题，使得代码更加清晰和安全。

在没有 `override` 关键字之前，程序员可能会犯一些错误，例如：

1.  拼写错误：在派生类中复写基类虚函数时，函数名拼写错误，导致无法正确覆盖基类虚函数。
2.  函数签名不匹配：派生类中的函数参数或返回类型与基类虚函数不一致，无法正确覆盖。
3.  未意识到基类虚函数改动：在基类中修改虚函数签名时，可能忘记修改派生类中的相应函数，导致逻辑错误。

引入 `override` 关键字后，这些问题可以得到解决：

1.  强制检查：编译器会检查带有 `override` 关键字的函数是否确实覆盖了基类的虚函数。如果没有正确覆盖，编译器会报错。
2.  更清晰的代码：通过使用 `override` 关键字，明确表示派生类中的函数是用于覆盖基类虚函数，增加代码可读性。

`override` 使用的注意事项：

1.  仅用于虚函数：`override` 关键字仅适用于虚函数覆盖。如果在非虚函数上使用，编译器会报错。
2.  不能与 `virtual` 同时使用：虽然 `override` 函数本身也是虚函数，但使用 `override` 关键字时，不需要在派生类中再显式地添加 `virtual` 关键字。
3.  只检查签名：`override` 关键字会检查派生类中的函数签名是否与基类虚函数完全匹配。如果签名不匹配，编译器将报错。需要注意的是，这里的匹配仅包括函数参数和返回类型，不包括函数的 `const` 和 `noexcept` 限定符。
4.  确保基类虚函数可访问：派生类中的 `override` 函数需要访问基类中的虚函数。因此，如果基类中的虚函数是私有的（private），派生类将无法覆盖它，编译器会报错。

在使用 `override` 关键字时，还可以考虑使用 `final` 关键字来防止进一步覆盖。`final` 关键字可以用于类或虚函数，表示不允许进一步的继承或覆盖。这有助于确保类的稳定性和设计的完整性。

```cpp
#include <iostream>

class Base {
public:
    virtual void foo() {
        std::cout << "Base::foo()" << std::endl;
    }
};

class Derived : public Base {
public:
    void foo() override final {
        std::cout << "Derived::foo()" << std::endl;
    }
};

class FurtherDerived : public Derived {
public:
    // 以下代码将导致编译错误，因为 Derived::foo() 被标记为 final
    /*
    void foo() override {
        std::cout << "FurtherDerived::foo()" << std::endl;
    }
    */
};

int main() {
    FurtherDerived fd;
    Base* b = &fd;

    b->foo(); // 输出：Derived::foo()

    return 0;
}
```

此外，在使用显式虚函数覆写时，还需要注意一些编程最佳实践：

1.  始终使用 `override`：在派生类中覆盖虚函数时，尽量始终使用 `override` 关键字。这将提高代码的可读性，同时避免因拼写错误或签名不匹配等问题导致的潜在错误。
    
2.  尽量将虚函数声明为 `protected`：在设计类时，将虚函数声明为 `protected`，而非 `public`，有助于限制外部对虚函数的直接访问。这样可以确保派生类能够正确地覆盖虚函数，而不会因为外部直接调用基类虚函数导致潜在问题。
    
3.  使用纯虚函数定义接口：在抽象基类中，可以使用纯虚函数来定义接口。纯虚函数没有实现，派生类必须提供实现，否则将无法实例化。这有助于确保派生类正确实现了基类定义的接口。
    
4.  优先考虑组合而非继承：在设计类时，应优先考虑组合而非继承。继承可能导致类层次过于复杂，使得代码难以维护。通过组合，可以更灵活地实现类的功能，并降低类之间的耦合。
    
5.  理解虚函数调用开销：虚函数调用通常比普通函数调用开销略大，因为它需要通过虚函数表查找相应的函数实现。在性能关键的场景中，要注意权衡虚函数带来的便利性和性能开销。
    

通过遵循这些最佳实践，可以更好地利用显式虚函数覆写和其他继承多态相关特性，编写高质量的 C++ 代码。总之，显式虚函数覆写是一种有用的 C++ 特性，它可以提高代码的安全性、可读性和可维护性。在实际项目中，建议充分利用这个特性，以及其他 C++ 继承和多态相关的最佳实践，以实现更健壮、高效的代码。


## 匿名函数

从c++14开始我们可以用任意表达式初始化捕获到的变量
```cpp
#include <iostream>
#include <memory>  // std::make_unique
#include <utility> // std::move

void lambda_expression_capture() {
    auto important = std::make_unique<int>(1);
    auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -> int {
        return x+y+v1+(*v2);
    };
    std::cout << add(3,4) << std::endl;
}
```

从c++14起我们还可以写泛型lambda了
```cpp
void lambda_generic() {
    auto generic = [](auto x, auto y) {
        return x+y;
    };

    std::cout << generic(1, 2) << std::endl;
    std::cout << generic(1.1, 2.2) << std::endl;
}
```

## function object wrapper

在 C++ 中，`function object wrapper`（函数对象包装器）是一种通用、可调用对象的包装器。它通常指的是 `std::function` 模板类，定义在 `<functional>` 头文件中。`std::function` 可以存储、复制和调用任何可调用目标（callable target），包括函数指针、成员函数指针、函数对象（functor）和 lambda 表达式。

`std::function` 的主要优点是它提供了一种统一的接口来处理各种可调用对象。这使得编写泛型代码变得更容易，因为可以在不了解具体可调用对象类型的情况下使用它们。此外，`std::function` 可以实现像回调函数、事件处理器等编程模式。

下面是一个简单的 `std::function` 示例：

```cpp
#include <iostream>
#include <functional>

// 普通函数
void print_hello() {
    std::cout << "Hello from a regular function!" << std::endl;
}

// 函数对象（functor）
struct PrintWorld {
    void operator()() {
        std::cout << "World from a function object!" << std::endl;
    }
};

int main() {
    // 使用 std::function 存储普通函数指针
    std::function<void()> func1 = print_hello;
    func1();

    // 使用 std::function 存储函数对象
    PrintWorld print_world;
    std::function<void()> func2 = print_world;
    func2();

    // 使用 std::function 存储 lambda 表达式
    std::function<void()> func3 = []() {
        std::cout << "Hello world from a lambda expression!" << std::endl;
    };
    func3();

    return 0;
}
```

在这个示例中，我们使用 `std::function` 存储了三种不同类型的可调用对象：普通函数、函数对象和 lambda 表达式。`std::function` 为它们提供了统一的接口，我们可以直接调用这些可调用对象，而不需要关心它们的具体类型。

`std::function` 的模板参数表示可调用对象的签名。例如，`std::function<void()>` 表示一个返回类型为 `void`、无参数的可调用对象。如果可调用对象具有参数和返回值，则需要相应地调整模板参数，例如：`std::function<int(int, int)>` 表示一个接受两个 `int` 参数并返回 `int` 类型的可调用对象。

`std::function` 还支持成员函数指针和可变参数。使用 `std::bind` 或 C++14 引入的 lambda 表达式捕获列表，可以将成员函数指针绑定到具体对象，然后存储在 `std::function` 中。

总之，C++ 中的函数对象包装器，特指 `std::function` 模板类，提供了一种统一的接口来处理各种可调用对象。这使得编写泛型代码变得更容易，并有助于实现诸如回调函数、事件处理器等编程模式。`std::function` 提高了 C++ 代码的灵活性和可扩展性。

以下是一些与 `std::function` 相关的高级用法和注意事项：

1.  延迟计算：`std::function` 可以用于实现延迟计算（lazy evaluation）。通过将可调用对象存储在 `std::function` 中，可以在实际需要时执行计算，而不是立即计算。这在计算量大的任务中非常有用，可以有效地分配计算资源。
    
2.  空 `std::function`：`std::function` 可以为空，表示没有关联的可调用对象。可以使用默认构造函数创建空的 `std::function`，或者将其赋值为 `nullptr`。在调用空的 `std::function` 时，会抛出 `std::bad_function_call` 异常。在使用 `std::function` 之前，可以使用 `operator bool()` 成员函数检查其是否为空。
    
3.  与 `std::bind` 配合使用：`std::bind` 函数可以将可调用对象与其参数进行绑定，创建新的可调用对象。绑定后的可调用对象可以存储在 `std::function` 中。这在需要对参数进行预处理或将多参数函数转换为单参数函数时非常有用。
    
4.  性能开销：虽然 `std::function` 提供了很多便利性，但它也带来了一定的性能开销。这是因为它可能使用动态内存分配来存储可调用对象，并通过虚拟调用来执行。在性能关键场景中，需要权衡 `std::function` 的便利性和性能开销。有时候可以考虑使用其他泛型编程技术，如模板函数或模板类。
    
5.  多线程安全：`std::function` 本身不是线程安全的。在多线程环境中，需要确保对 `std::function` 对象的访问是同步的。此外，要注意存储在 `std::function` 中的可调用对象的线程安全性。
    

通过充分利用 `std::function` 及其相关特性，可以编写更灵活、可扩展的 C++ 代码。在实际项目中，应结合具体需求和场景，恰当地使用 `std::function`，以实现高质量的软件设计。



