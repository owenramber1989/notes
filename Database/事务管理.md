## 可恢复调度与无级联调度
可恢复调度：如果事务a的修改被事务b读取了，那么事务a就必须在事务b提交之前提交
无级联调度：如果事务Tj读取了事务Ti的修改，那么Ti必须在Tj读取之前提交，这样就可以避免级联回滚了
## 幻读
幻读（Phantom Read）是数据库事务隔离中的一种现象，它发生在一个事务在一定范围内多次读取数据时，另一个事务同时在该范围内插入或删除了一些数据行。这导致第一个事务在两次读取之间观察到了新的、"幻影"的数据行。(phantom row)

幻读主要是因为数据库并发控制不足导致的。与不可重复读（Non-repeatable Read）现象不同，幻读关注的是查询结果中新出现或消失的数据行，而不可重复读关注的是数据行内容的变化。

为了深入理解幻读现象，我们可以考虑以下示例：

假设有两个事务：T1 和 T2。以下是这两个事务的操作顺序：
1.  事务 T1 读取范围 A（例如，读取年龄在 18 到 25 岁之间的所有用户）。
2.  事务 T2 插入一个新的数据行，使其位于范围 A 内（例如，插入一个年龄为 23 岁的新用户）。
3.  事务 T2 提交。
4.  事务 T1 再次读取范围 A。

在这个例子中，事务 T1 在第二次读取范围 A 时，会发现一个新的数据行（新插入的用户），这就是幻读现象。

为了解决幻读问题，数据库系统通常会实施一定程度的隔离，这是通过事务隔离级别（Transaction Isolation Levels）来实现的。在 SQL 标准中，定义了四个事务隔离级别：
1.  读未提交（Read Uncommitted）
2.  读已提交（Read Committed）
3.  可重复读（Repeatable Read）
4.  串行化（Serializable）

在可重复读（Repeatable Read）隔离级别下，数据库系统会使用锁或多版本并发控制（MVCC）来防止同一事务中的不可重复读现象。然而，可重复读隔离级别并不能完全防止幻读现象。

要解决幻读问题，需要使用最高级别的事务隔离级别：串行化（Serializable）。在串行化隔离级别下，事务是顺序执行的，这意味着在任何给定时间只能有一个事务在执行。通过强制执行顺序，可以确保同一范围内的数据不会在事务执行期间发生变化，从而消除幻读现象。

然而，使用串行化隔离级别会带来性能开销，因为事务必须排队等待执行。因此，在实际应用中，需要根据具体需求和容忍度来权衡是否使用串行化隔离级别。如果应用程序可以容忍一定程度的数据不一致，例如在读取大量数据进行分析时，那么可以选择较低的隔离级别以提高性能。然而，在处理关键业务数据或需要确保数据完整性的场景中，使用串行化隔离级别可能是更好的选择，以确保数据的一致性和正确性。

在实践中，也可以采用其他策略来解决或降低幻读现象的影响，例如：

1.  使用悲观锁：悲观锁假定多个事务之间可能发生冲突，并在事务开始时对数据进行加锁，以确保在事务执行期间其他事务无法对数据进行修改。这可以避免幻读现象，但可能导致更高的锁竞争和性能损失。
    
2.  使用乐观锁：乐观锁假设多个事务之间不太可能发生冲突，并允许它们并发执行。在事务提交时，会检查数据是否已经被其他事务修改。如果检测到冲突，事务将被回滚并重新尝试。乐观锁可以降低锁竞争，但在高冲突场景下可能导致更高的回滚率。
    
3.  分区或分片：通过将数据分成较小的部分（例如，根据年龄或地理位置），可以减少多个事务之间的竞争，从而降低幻读现象的可能性。
    
4.  使用多版本并发控制（MVCC）：一些数据库系统（如 PostgreSQL 和 MySQL/InnoDB）使用 MVCC 作为并发控制策略。在 MVCC 中，每个事务都看到一个数据的快照，而不是实时数据。这样可以避免锁的开销，同时降低不可重复读和幻读现象的可能性。
    

总之，幻读现象是数据库事务隔离中的一个问题，可以通过提高事务隔离级别、使用锁策略或其他技术来解决或降低影响。在实际应用中，需要根据具体场景和需求来选择合适的策略。

## 四大隔离级别

1. 读未提交，也称为脏读
2. 读已提交， 这个级别依然允许不可重复读（nonrepeatable read), 同一事务中两次执行相同的语句可能会看到不同的数据结果
3. 可重复读，是mysql默认的事务隔离级别
4. 可串行划， 在读取的每一行数据上都加锁