## 快照隔离

快照隔离（Snapshot Isolation，SI）是一种数据库并发控制技术，用于在事务处理过程中维护一致性。它是一种折衷方法，介于传统的读写锁定（锁定）和无锁定并发控制技术之间。快照隔离通过在事务开始时为数据库创建一个快照，让事务在此快照上进行读操作，从而实现隔离。

快照隔离的核心思想是在事务开始时为其创建一个数据库的只读副本，也就是快照。事务在这个快照上执行读操作，从而避免了事务间的读-读冲突。写操作仍然在原始数据库上执行，但在提交事务之前，系统需要检查是否存在写-写冲突。如果存在冲突，事务需要被回滚并重试。

快照隔离具有以下特点

1.  隔离级别：快照隔离提供了一种比读已提交（Read Committed）更高的隔离级别，因为它能防止脏读、不可重复读和幻读。然而，快照隔离可能会导致一种名为"写偏"（Write Skew）的异常，即两个事务同时修改不相交的数据集，并在提交时产生冲突。
    
2.  多版本并发控制（MVCC）：快照隔离通常依赖多版本并发控制技术实现。MVCC通过为每个事务创建一个时间戳来追踪数据版本。当事务读取数据时，它只能访问其开始时刻之前的数据版本。当事务写入数据时，它会创建一个新的数据版本，以确保其他并发事务能够访问旧版本的数据。
    
3.  冲突检测与解决：在快照隔离下，事务提交前需要检查是否存在写-写冲突。这可以通过检查提交事务的时间戳与数据库中数据项的时间戳来实现。如果提交事务的时间戳早于数据项的时间戳，说明在事务执行期间，有其他事务已经修改了该数据项，从而产生了冲突。此时，事务需要回滚并重新执行。这种策略被称为"优先提交"（First-Committer-Wins）。
    
4.  性能优势：与传统的锁定并发控制相比，快照隔离可以显著提高数据库性能，因为它降低了事务之间的锁定竞争。事务可以在快照上执行读操作，无需等待其他事务释放锁


## SSI

可串行化快照隔离（Serializable Snapshot Isolation，SSI）是一种数据库并发控制技术，它结合了快照隔离（Snapshot Isolation，SI）的优点和可串行化（Serializable）的强一致性保证。快照隔离允许多个事务并发执行，同时为每个事务提供一个隔离的快照，使其能够在与其他事务同时进行时，读取一致的数据状态。然而，快照隔离可能导致一些并发异常，如写偏（Write Skew）和幻读（Phantom Reads）。SSI 通过检测并阻止这些异常，实现了与串行执行事务相同的结果。

SSI 通过以下几个关键概念来实现可串行化：

1.  快照：SSI 为每个事务提供一个基于其启动时间的数据快照。这意味着事务只能看到在它启动之前提交的数据更改，而不受其他并发事务的影响。
    
2.  读写依赖跟踪：SSI 跟踪事务读取和修改的数据项。当一个事务尝试提交时，系统会检查是否存在与其他事务之间的依赖关系。例如，一个事务可能读取了另一个事务修改的数据，或者两个事务尝试修改同一数据项。
    
3.  依赖循环检测：SSI 检测事务之间的依赖关系是否形成了循环。如果存在循环依赖，那么这些事务就无法串行执行，因此，需要终止并回滚其中一个事务，以确保系统的可串行化。
    
4.  读和写的冲突检测：SSI 在事务提交时检查是否有其他事务修改了它读取的数据。如果存在冲突，SSI 会阻止事务提交，以确保数据的一致性。
    

SSI 的优势在于它在保证可串行化的同时，允许多个事务并发执行。这样可以提高数据库的吞吐量和性能。然而，SSI 也存在一定的开销，因为系统需要跟踪事务之间的依赖关系并进行冲突检测。在冲突较少的场景下，SSI 的性能通常优于其他串行化技术。但在高冲突的场景中，SSI 可能需要频繁回滚事务，从而降低性能。

总之，SSI 是一种兼顾并发性能和数据一致性的数据库并发控制技术。它通过跟踪事务之间的依赖关系并检测冲突，实现了与串行执行事务相同


## 一致性快照

一致性快照（Consistent Snapshot）是数据库中的一个概念，用于确保在特定时间点上获取的数据集是一致的。这种技术通常用于备份、恢复和并发控制。在许多数据库管理系统（DBMS）中，实现一致性快照的技术被称为多版本并发控制（MVCC）。

多版本并发控制（MVCC）允许数据库在执行事务时为每个事务创建一个数据的“快照”。这样，即使在事务执行期间数据发生更改，事务仍然可以看到它开始时的数据状态。这有助于解决事务之间的冲突，确保数据的一致性。

以下是一个简单的示例，说明一致性快照的概念：

假设我们有一个名为“employees”的数据库表，其中包含以下数据：

![[Pasted image 20230401082117.png]]

现在，假设我们有两个并发事务：

1.  事务A：查询员工的总薪资。
2.  事务B：为Bob增加薪水1000。

在没有一致性快照的情况下，事务A可能会在事务B完成前查询到Alice的薪水，而在事务B完成后查询到Bob的薪水。这将导致事务A计算出的总薪资不一致。

但是，使用一致性快照（通过MVCC实现），数据库会为事务A创建一个数据快照。这意味着事务A将看到一个一致的数据视图，即使事务B同时进行。因此，事务A可以正确计算总薪资，而不受事务B的影响。

在实际操作中，MVCC通过为每个数据行分配一个版本号来实现。当事务开始时，它会获得一个事务ID。在读取数据时，事务只能看到其事务ID早于或等于其自身事务ID的数据行。当事务修改数据时，它会创建一个新的数据行版本，并将该版本与自身的事务ID关联。

这种方法确保了每个事务都能看到一个一致的数据视图，同时避免了悲观锁定所导致的性能问题。

总之，一致性快照通过为事务提供一致的数据视图来确保数据一致性，尤其是在并发事务的情况下。多版本并发控制（MVCC）是一种实现一致性快照的广泛应用的技术，它可以解决事务之间的冲突，提高数据库性能。



## 各种一致性

在并发控制中，一致性是指对多个操作的执行顺序和可见性的约束。以下是一些常见的并发控制一致性概念：

1.  顺序一致性（Sequential Consistency）： 顺序一致性要求对于所有处理器或节点，它们看到的操作顺序都是全局一致的。换句话说，系统中的所有操作必须按照某个全局顺序执行，所有处理器或节点都必须遵循这个顺序。顺序一致性是最直观、最容易理解的一种一致性模型，但实际应用中可能导致性能下降，因为它限制了操作的并行性和优化。
    
2.  线性一致性（Linearizability）： 线性一致性要求对于每个操作，存在一个全局的线性顺序，使得所有处理器或节点看到的操作顺序是一致的。与顺序一致性不同，线性一致性允许在不影响全局顺序的情况下对操作进行并行执行和优化。线性一致性通常用于实现原子操作、锁和同步原语等，并在分布式系统中广泛使用。
    
3.  因果一致性（Causal Consistency）： 因果一致性是一种较弱的一致性模型，要求系统中具有因果关系的操作必须按照因果顺序执行。具有因果关系的操作指的是两个操作之间存在某种直接或间接的依赖关系，例如一个操作是对另一个操作的响应。因果一致性允许对因果无关的操作进行并行执行和优化，从而提高性能。然而，因果一致性不能保证全局一致性，因为不同处理器或节点可能看到不同的操作顺序。
    
4.  读写一致性（Read-Your-Writes Consistency）： 读写一致性要求一个处理器或节点执行的写操作对其后续的读操作始终可见。换句话说，一个处理器或节点永远不会读到它之前写入的过期数据。读写一致性适用于需要保证单个处理器或节点操作顺序的场景，但它不能保证全局一致性。
    
5.  会话一致性（Session Consistency）： 会话一致性是读写一致性的扩展，要求在一个会话内，对于每个处理器或节点，所有操作的执行顺序都是一致的。会话一致性适用于需要在会话范围内保证操作顺序的场景，但同样不能保证全局一致性。
    

这些一致性概念在并发控制中具有不同的权衡和适用场景。更强的一致性模型通常意味着更高的性能开销和更低的并发性能，而较弱的一致性模型在提高并发性能的同时，可能导致应用程序开发人员面临更多的复杂性和一致性问题。

6.  最终一致性（Eventual Consistency）： 最终一致性是一种较弱的一致性模型，它只要求在系统无新的更新操作时，所有处理器或节点最终会看到相同的数据状态。在最终一致性模型下，不同处理器或节点在短时间内可能看到不同的数据状态，但随着时间的推移，数据状态将趋于一致。最终一致性适用于对一致性要求较低、可接受短暂不一致的场景，例如 DNS 系统和分布式存储系统。
    
7.  单调读一致性（Monotonic Read Consistency）： 单调读一致性要求在一个处理器或节点上，对于同一个数据项的多次读操作，后续的读操作不能返回比前一个读操作更旧的数据。换句话说，单调读一致性保证每个处理器或节点读取数据时，数据状态是单调递增的。单调读一致性适用于需要避免读操作返回过期数据的场景。
    
8.  单调写一致性（Monotonic Write Consistency）： 单调写一致性要求在一个处理器或节点上，对于同一个数据项的多次写操作，后续的写操作不能被执行在比前一个写操作更早的时间点。单调写一致性适用于需要保证写操作按照执行顺序递增的场景。
    

这些一致性模型提供了不同程度的一致性保证和并发性能。在选择合适的一致性模型时，应考虑应用程序的需求、性能要求以及开发人员的经验。通常，强一致性模型更适用于需要保证数据完整性和一致性的关键应用，而弱一致性模型更适用于可容忍短暂不一致、对性能和可用性有较高要求的应用。


## 事务隔离的四个等级

事务隔离等级是数据库管理系统（DBMS）为了解决并发事务中潜在问题而提供的一种机制。事务隔离等级的定义可以在 SQL 标准中找到。一共有四个隔离等级，从低到高分别是：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和可串行化（Serializable）。隔离等级越高，所提供的一致性保证越强，但可能导致并发性能降低。

1.  读未提交（Read Uncommitted）： 读未提交是最低的事务隔离等级，允许事务读取尚未提交的其他事务所做的更改。在这个隔离等级下，可能出现脏读（Dirty Read）现象，即一个事务读取到了另一个尚未提交的事务所做的更改。这可能导致不一致的数据状态。
    
2.  读已提交（Read Committed）： 读已提交是较低的事务隔离等级，只允许事务读取已经提交的其他事务所做的更改。这可以防止脏读现象，但仍然可能出现不可重复读（Non-repeatable Read）现象，即一个事务在不同时间执行相同的查询操作，返回的结果可能不同。这是因为其他事务可能在此期间提交了对数据的更改。
    
3.  可重复读（Repeatable Read）： 可重复读是较高的事务隔离等级，确保在同一个事务中多次读取相同数据时，数据保持一致。这可以防止不可重复读现象。但是，在这个隔离等级下仍然可能出现幻读（Phantom Read）现象，即一个事务在执行相同的范围查询时，可能发现了其他事务新插入的行。
    
4.  可串行化（Serializable）： 可串行化是最高的事务隔离等级，它要求所有事务必须按照顺序串行执行，即一个事务完成后，另一个事务才能开始。在这个隔离等级下，可以防止脏读、不可重复读和幻读现象，确保数据的一致性。然而，由于事务顺序执行，这可能导致并发性能降低。
    

事务隔离等级的选择需要在数据一致性和并发性能之间进行权衡。对于需要高度一致性的应用，可以选择较高的隔离等级，如可串行化；对于对并发性能有较高要求的应用，可以选择较低的隔离等级，如读已提交。



## 读偏差 Read Skew

读偏差（Read Skew）是数据库中一种可能发生的数据不一致现象，它通常出现在事务并发执行的场景中。在这种情况下，一个事务在读取多个表或者多个数据项时，可能会遇到其他事务对这些数据项的修改，从而导致读取的数据是不一致的。换句话说，读偏差是因为事务在执行过程中读取了不同时间点的数据，导致数据不一致。

为什么会出现读偏差？

读偏差出现的原因是多个事务并发执行，以及事务隔离级别的设置。如果事务隔离级别较低（如 Read Committed 或 Read Uncommitted），则事务在读取数据时可能会受到其他事务的影响，从而导致数据不一致。

如何解决？

要解决读偏差问题，可以采用以下方法之一：

1.  提高事务隔离级别：将事务隔离级别设置为 Repeatable Read 或 Serializable 可以减少或消除读偏差。在这些隔离级别下，事务在读取数据时会“锁定”相关数据项，防止其他事务在此期间进行修改。这样，事务读取的数据会保持一致性。然而，提高事务隔离级别可能会降低系统的并发性能，因为锁定会导致事务等待。
    
2.  使用乐观锁（Optimistic Locking）：乐观锁是一种无锁设计策略，它允许多个事务在没有锁的情况下并发访问数据。乐观锁的核心思想是，事务在提交时检查它所读取的数据是否已被其他事务修改。如果没有，事务提交成功；如果有，事务回滚并重试。乐观锁可以通过版本号或时间戳等机制实现。
    

示例：

假设我们有一个银行账户应用程序，该应用程序需要在两个账户之间转账。在 Read Committed 隔离级别下，可能会出现读偏差。以下是一个简化的示例：

1.  事务 A 开始执行，读取账户 X 和账户 Y 的余额。
2.  事务 B 开始执行，从账户 X 转移 100 元到账户 Y。
3.  事务 B 提交，修改后的余额已写入数据库。
4.  事务 A 再次读取账户 X 和账户 Y 的余额，这时读到的余额是不一致的。

要解决这个问题，可以将事务隔离级别设置为 Repeatable Read 或 Serializable，或者使用乐观锁来确保事务 A 读取的数据是一致的。以下是如何解决读偏差问题的示例：

1.  将事务隔离级别设置为 Repeatable Read 或 Serializable： 在这种情况下，事务 A 在第一次读取账户 X 和账户 Y 的余额时，会锁定这两个账户的数据。这将阻止事务 B 在事务 A 提交之前修改这两个账户的余额。因此，事务 A 读取的数据将保持一致。需要注意的是，这种方法可能会降低系统的并发性能，因为事务 B 可能需要等待事务 A 释放锁。
    
2.  使用乐观锁： 为了使用乐观锁，我们可以为每个账户添加一个版本号或时间戳。当事务 A 开始时，它将读取账户 X 和账户 Y 的余额以及它们的版本号。在事务 A 准备提交时，它会检查这两个账户的版本号是否发生了变化。如果版本号没有变化，说明事务 A 读取的数据仍然是一致的，可以提交。如果版本号发生了变化，说明事务 A 读取的数据可能已经过时，事务 A 需要回滚并重新执行。这种方法可以在无需使用锁的情况下保证数据的一致性，从而提高系统的并发性能。
    

总结：

读偏差是并发事务执行时可能遇到的一种数据不一致问题。要解决读偏差，可以通过提高事务隔离级别或使用乐观锁来确保事务读取的数据保持一致。需要注意的是，不同的解决方案可能会对系统的性能产生不同的影响。在实际应用中，需要根据具体场景和需求来选择合适的方法。


## 写偏

写偏（Write Skew）是一种数据库并发问题，发生在两个或多个事务同时读取相同的数据项，并根据读取的数据对其他数据项进行修改。这可能导致数据不一致的情况，尤其是在某些隔离级别下，如快照隔离（Snapshot Isolation）和可重复读（Repeatable Read）。

以一个银行账户的例子来说明写偏现象：

假设有两个账户 A 和 B，每个账户的余额为 100。银行需要确保两个账户的总余额始终大于等于 100。现在有两个并发事务：

事务 T1：从账户 A 转出 60 元到账户 C。 事务 T2：从账户 B 转出 60 元到账户 D。

两个事务的执行顺序如下：

1.  T1 读取账户 A 的余额（100）。
2.  T2 读取账户 B 的余额（100）。
3.  T1 检查 A 的余额足够，将 A 的余额更新为 40。
4.  T2 检查 B 的余额足够，将 B 的余额更新为 40。

在这种情况下，两个事务都提交成功。但是，两个账户的总余额（A + B = 40 + 40 = 80）小于 100，违反了银行的约束。

为了解决写偏问题，可以采用以下策略：

1.  使用悲观锁：在读取数据时，为数据加锁，阻止其他事务修改。这样可以确保事务之间的串行执行，但可能导致性能下降，因为事务需要等待锁释放。
    
2.  使用乐观锁：乐观锁允许事务并发读取数据，但在提交时检查数据是否发生了变化。如果数据已被其他事务修改，当前事务需要回滚并重新执行。这种方法适用于冲突较少的场景，因为它可以提高并发性能。
    
3.  使用可串行化隔离级别（Serializable Isolation）：可串行化隔离级别可以防止写偏问题，因为它确保事务的执行结果与串行执行的结果相同。然而，这种隔离级别可能导致性能下降，因为它限制了事务的并发执行。
    
4.  使用可串行化快照隔离（Serializable Snapshot Isolation，SSI）：SSI 结合了快照隔离的优点和可串行化的一致性保证。它通过跟踪事务之间的依赖关系并防止写偏异常，实现了与串行执行事务相同的结果。SSI 适用于需要高并发性能和数据一致性


## 锁

### 乐观锁与悲观锁

乐观锁和悲观锁是数据库并发控制中两种常见的锁机制。它们分别基于乐观和悲观的并发策略，旨在解决多个事务同时访问和修改数据时可能出现的数据不一致问题。下面详细介绍乐观锁和悲观锁以及它们在实际应用中的使用方法。

1.  乐观锁：

乐观锁的基本思想是在事务执行过程中不加锁，只在事务提交时检查数据是否发生了冲突。乐观锁适用于并发冲突较少的场景，因为它假定多个事务在大多数情况下不会互相干扰。乐观锁可以通过版本号或时间戳来实现。

示例：

假设我们有一个电商系统，其中包含一个库存表，表中有一个字段记录库存数量（stock）和一个版本号（version）字段。当用户购买商品时，系统会尝试减少库存。

伪代码如下：

```sql
begin_transaction;
// 读取库存和版本号
SELECT stock, version FROM inventory WHERE item_id = ?;
// 检查库存是否充足
if (stock >= requested_quantity) {
    // 更新库存和版本号
    UPDATE inventory SET stock = stock - requested_quantity, version = version + 1 WHERE item_id = ? AND version = ?;
    if (affected_rows == 1) {
        // 提交事务
        commit_transaction;
        return SUCCESS;
    } else {
        rollback_transaction;
        return RETRY;
    }
} else {
    rollback_transaction;
    return INSUFFICIENT_STOCK;
}
```

2.  悲观锁：

悲观锁的基本思想是在事务执行过程中对数据加锁，以防止其他事务修改被锁定的数据。悲观锁适用于并发冲突较多的场景，因为它假定多个事务在大多数情况下会互相干扰。悲观锁可以通过数据库的行锁或表锁来实现。

示例：

仍然使用上面的电商系统为例，当用户购买商品时，我们可以通过加锁来确保库存数据的一致性。

伪代码如下：
```sql
begin_transaction;
// 通过 SELECT FOR UPDATE 语句加锁
SELECT stock FROM inventory WHERE item_id = ? FOR UPDATE;
// 检查库存是否充足
if (stock >= requested_quantity) {
    // 更新库存
    UPDATE inventory SET stock = stock - requested_quantity WHERE item_id = ?;
    // 提交事务，释放锁
    commit_transaction;
    return SUCCESS;
} else {
    // 回滚事务，释放锁
    rollback_transaction;
    return INSUFFICIENT_STOCK;
}
```
在实际应用中，乐观锁和悲观锁的选择取决于系统的具体需求和并发状况。在决定使用哪种锁时，需要权衡它们在性能和数据一致性方面的优劣。

乐观锁适用于读多写少的场景，因为在这种情况下，事务冲突的概率较低。乐观锁可以避免在事务执行过程中持有锁，从而减少了锁等待和死锁的可能性。但是，如果系统中的并发冲突较多，乐观锁可能导致大量的事务回滚和重试，从而降低性能。

悲观锁适用于写多的场景，因为在这种情况下，事务冲突的概率较高。悲观锁通过在事务执行过程中加锁，确保了数据的一致性。然而，这种锁机制可能导致事务等待锁和死锁问题，从而影响性能。

在实际应用中，有时可以结合使用乐观锁和悲观锁。例如，可以使用乐观锁处理那些对数据一致性要求较低的操作，而对于那些对数据一致性要求较高的操作，则使用悲观锁。

总之，选择乐观锁还是悲观锁取决于系统的需求和并发状况。在实际应用中，可以根据具体场景灵活选择合适的锁机制，以实现最佳的性能和数据一致性。

## 两阶段锁

两阶段锁定（Two-Phase Locking, 2PL）是一种广泛应用于数据库管理系统的并发控制协议。它的核心思想是让事务在操作数据时遵循一定的锁定规则，以确保事务的隔离性和一致性。两阶段锁定协议可以防止不可重复读、脏读和幻读等现象的发生。

两阶段锁定包括两个阶段：加锁阶段（Locking Phase）和解锁阶段（Unlocking Phase）。

1.  加锁阶段（Locking Phase）： 在这个阶段，事务在访问某个数据项之前需要先请求并获得相应的锁。根据操作类型，锁可以分为共享锁（Shared Lock，S锁）和排他锁（Exclusive Lock，X锁）。读操作需要获取共享锁，而写操作需要获取排他锁。一个数据项上可以有多个共享锁，但只能有一个排他锁。共享锁和排他锁之间是互斥的。

事务在加锁阶段可以逐步获取所需的锁，但一旦它开始释放锁，就不能再请求新的锁。这意味着事务在这个阶段必须一直累积锁，直到完成所有数据访问。

2.  解锁阶段（Unlocking Phase）： 在这个阶段，事务逐步释放已获得的锁。释放锁通常在事务提交或回滚之后进行。然而，在某些情况下，锁也可以在事务执行过程中逐步释放，以提高并发性能。需要注意的是，一旦事务进入解锁阶段，它不能再请求新的锁。

两阶段锁定协议有助于确保事务的隔离性，但可能导致死锁（Deadlock）现象。死锁是指两个或多个事务相互等待对方释放锁的情况，导致所有事务都陷入无法继续执行的状态。为了解决死锁问题，数据库管理系统通常采用死锁检测和死锁预防机制。

总之，两阶段锁定是一种广泛应用于数据库并发控制的协议，它通过严格的锁定规则来确保事务的隔离性和一致性。然而，它也可能导致死锁等问题，需要数据库管理系统采取相应的措施进行处理。


