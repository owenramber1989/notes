

## 应用层协议

### HTTP

在网络通信中，握手和挥手这两个过程分别是在 TCP 连接建立和关闭时进行的。HTTP 和 HTTPS 协议都是基于 TCP 连接的应用层协议，因此握手和挥手的次数与 TCP 协议相关，而不是 HTTP 或 HTTPS 协议本身。无论是 HTTP 还是 HTTPS，它们的握手和挥手次数相同。

TCP 握手（三次握手）：

1.  第一次握手：客户端发送一个 SYN（同步）报文到服务器，请求建立连接。这个报文包含一个随机生成的序列号 A。
2.  第二次握手：服务器收到 SYN 报文后，返回一个 SYN+ACK（同步确认）报文给客户端。这个报文包含一个随机生成的序列号 B 和对客户端序列号 A 的确认（A+1）。
3.  第三次握手：客户端收到 SYN+ACK 报文后，发送一个 ACK（确认）报文给服务器，确认服务器的序列号 B（B+1）。此时，TCP 连接建立完成。

TCP 挥手（四次挥手）：

1.  第一次挥手：当客户端完成数据传输后，发送一个 FIN（结束）报文给服务器，请求关闭连接。
2.  第二次挥手：服务器收到 FIN 报文后，发送一个 ACK（确认）报文给客户端，确认客户端的 FIN 报文。然后，服务器继续处理剩余的数据。
3.  第三次挥手：当服务器完成数据处理后，发送一个 FIN（结束）报文给客户端，表示服务器也准备好关闭连接了。
4.  第四次挥手：客户端收到服务器的 FIN 报文后，发送一个 ACK（确认）报文给服务器，确认服务器的 FIN 报文。然后，客户端等待一段时间（2MSL，最长报文段寿命的两倍），以确保服务器收到 ACK 报文。一旦等待时间过去，TCP 连接关闭。

需要注意的是，HTTPS 协议在 TCP 三次握手之后还有一个 TLS/SSL 握手过程，用于建立加密通道。这个过程涉及到客户端和服务器之间的多次报文交换，包括密钥交换、证书验证等。然而，这个过程与 TCP 握手和挥手不同，因此在计算握手和挥手次数时，通常不考虑 TLS/SSL 握手过程。

### 报文格式

HTTP GET和POST请求是HTTP协议中两种常见的请求方法。它们在客户端与服务器之间传输数据时具有一些不同的特点。以下是GET和POST请求报文的主要区别：

1.  请求方式：GET请求使用URL的查询字符串携带参数，而POST请求将参数放在请求体（Request Body）中。
    
2.  安全性：因为GET请求将参数直接放在URL中，这使得敏感信息容易被保存在浏览器的历史记录、代理服务器日志、网络抓包工具等处泄露。而POST请求将数据放在请求体中，较GET请求来说安全性更高。但需要注意的是，HTTP POST请求本身也并不安全，因为数据在传输过程中仍然是明文。为了确保安全性，应当使用HTTPS加密传输。
    
3.  数据长度：GET请求的参数长度受到URL长度的限制，不同浏览器和服务器对URL长度的限制可能不同，通常限制在2048个字符以内。而POST请求没有明确的长度限制，可以传输大量数据。
    
4.  缓存：GET请求的结果可以被浏览器缓存，从而提高响应速度。而POST请求的结果通常不会被缓存，每次请求都需要向服务器发送请求并等待响应。
    
5.  数据类型：GET请求仅支持ASCII字符集，对于非ASCII字符，需要进行URL编码。POST请求可以发送任何类型的数据，包括二进制数据。
    
6.  幂等性：GET请求具有幂等性，意味着多次相同的GET请求对资源产生的影响与一次请求相同。而POST请求不具备幂等性，多次相同的POST请求可能会对资源产生多次影响。
    
7.  请求语义：GET请求通常用于获取资源信息，而POST请求通常用于提交数据、创建新资源或者更新资源。
8.  GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100（指示信息—表示请求已接收，继续处理）continue，浏览器再发送data，服务器响应200 ok（返回数据）。

总之，GET和POST请求在传输数据的方式、安全性、数据长度、缓存、数据类型、幂等性以及请求语义方面有着明显的区别。在实际应用中，应根据不同场景和需求选择合适的请求方式。


### TLS/SSL 握手

HTTPS 协议是基于 HTTP 协议的，其安全性得益于底层的 TLS/SSL 加密技术。在建立 HTTPS 连接时，会进行一个 TLS/SSL 握手过程，以建立加密通道并对服务器进行身份验证。以下是 TLS/SSL 握手过程的详细步骤：

1.  客户端发送客户端Hello消息：客户端发起 TLS/SSL 握手，发送一个客户端Hello消息给服务器。这个消息包含了客户端支持的 TLS/SSL 版本、加密套件列表（包含密钥交换算法和加密算法）、压缩方法列表以及一个客户端生成的随机数（Client Random）。
    
2.  服务器发送服务器Hello消息：服务器收到客户端Hello消息后，从客户端提供的选项中选择最佳的 TLS/SSL 版本、加密套件和压缩方法，然后发送一个服务器Hello消息给客户端。这个消息中包含一个服务器生成的随机数（Server Random）。
    
3.  服务器发送证书：服务器向客户端发送其数字证书。数字证书包含了服务器的公钥和证书颁发机构（CA）的签名。客户端会使用这个证书来验证服务器的身份，确保与正确的服务器建立连接。
    
4.  服务器发送服务器密钥交换消息（可选）：如果所选的密钥交换算法需要服务器提供额外的信息，服务器会发送一个服务器密钥交换消息。例如，在使用 Diffie-Hellman 密钥交换时，服务器会在这个消息中发送其公钥参数。
    
5.  服务器发送证书请求消息（可选）：如果服务器需要客户端提供证书以进行双向身份验证，服务器会发送一个证书请求消息。这种情况在客户端需要进行身份验证的场景下较为常见，例如访问需要登录的网站。
    
6.  服务器发送服务器HelloDone消息：服务器发送一个服务器HelloDone消息，告知客户端服务器已经发送完所有需要的信息，等待客户端的响应。
    
7.  客户端验证服务器证书：客户端收到服务器的证书后，会验证证书的合法性。验证过程包括检查证书是否过期、颁发者是否可信以及证书是否被篡改等。
    
8.  客户端发送客户端密钥交换消息：客户端生成一个预主密钥（Pre-Master Secret），然后使用服务器的公钥加密，并将加密后的预主密钥发送给服务器。这样，客户端和服务器都拥有了相同的预主密钥。
    
9.  客户端发送证书（可选）：如果服务器请求客户端提供证书进行双向身份验证，客户端会发送自己的证书给服务器。
    
10.  客户端发送证书验证消息（可选）：如果客户端发送了证书，它还需要发送一个证书验证消息，以证明客户端拥有证书中的私钥。这个消息通常包含一个使用私钥签名的特定值，服务器可以使用客户端证书中的公钥对签名进行验证。
    
11.  客户端和服务器生成会话密钥：客户端和服务器分别使用预主密钥（Pre-Master Secret）、客户端随机数（Client Random）和服务器随机数（Server Random）计算出主密钥（Master Secret）。接下来，主密钥将用于生成会话密钥，包括客户端到服务器的加密密钥、服务器到客户端的加密密钥、客户端到服务器的 MAC 密钥和服务器到客户端的 MAC 密钥。会话密钥将在后续的通信中用于加密和验证消息。
    
12.  客户端发送Finished消息：客户端发送一个 Finished 消息给服务器，表示握手过程即将完成。这个消息使用前面生成的会话密钥加密，以验证密钥协商过程的正确性。
    
13.  服务器发送Finished消息：服务器收到客户端的 Finished 消息后，对其进行解密和验证。然后，服务器发送自己的 Finished 消息给客户端，也使用会话密钥加密。
    
14.  握手完成：一旦客户端和服务器都收到对方的 Finished 消息并成功解密验证，TLS/SSL 握手就完成了。从此开始，客户端和服务器将使用生成的会话密钥对所有通信进行加密和解密。
    

这就是 TLS/SSL 握手的完整过程。握手成功后，客户端和服务器就可以通过安全的加密通道进行通信。这为 HTTP 提供了安全性，从而使其成为 HTTPS。

## IPv4地址

IPv4 地址是一种 32 位的地址体系，它将整个地址空间划分为不同的范围，以满足各种不同的需求。这些范围通常被称为地址类（A、B、C、D 和 E），它们的主要用途如下：

1.  A 类地址：A 类地址的范围是 1.0.0.0 到 126.0.0.0。A 类地址用于大型组织或网络，因为它们的主要特点是拥有大量的 IP 地址。A 类地址的第一个字节是网络部分，后面三个字节是主机部分。这意味着可以有 126 个网络，每个网络最多可以有约 1,677 万个主机。
    
2.  B 类地址：B 类地址的范围是 128.0.0.0 到 191.255.0.0。B 类地址适用于中等规模的组织或网络。B 类地址的前两个字节是网络部分，后两个字节是主机部分。这意味着可以有 16,384 个网络，每个网络最多可以有 65,534 个主机。
    
3.  C 类地址：C 类地址的范围是 192.0.0.0 到 223.255.255.0。C 类地址主要用于小型组织或网络。C 类地址的前三个字节是网络部分，最后一个字节是主机部分。这意味着可以有 2,097,152 个网络，每个网络最多可以有 254 个主机。
    
4.  D 类地址：D 类地址的范围是 224.0.0.0 到 239.255.255.255。D 类地址不是为单个主机分配的，而是用于多播地址。多播允许将数据包发送到多个目的地，而无需将数据包发送到每个目的地。这种方法可以显著降低网络负载，因为数据包只需发送一次，然后由路由器复制并发送到多个接收者。
    
5.  E 类地址：E 类地址的范围是 240.0.0.0 到 255.255.255.255。这些地址被保留用于将来的实验和研究目的。它们目前不用于任何实际网络通信。
    

需要注意的是，除了这些主要的地址类之外，还有一些特殊的 IPv4 地址范围，例如本地回环地址（127.0.0.1）和私有地址空间（如 10.0.0.0/8，172.16.0.0/12 和 192.168.0.0/16），它们用于特定的用途和环境。


除了标准的 IPv4 地址类别之外，有几个特殊的 IPv4 地址范围具有特定的用途。以下是一些常见的特殊 IPv4 地址范围：

1.  本地回环地址：本地回环地址是一个特殊的地址范围，用于在本地计算机上进行网络通信。其地址范围是 127.0.0.0 到 127.255.255.255。其中，127.0.0.1 是最常用的本地回环地址。当向这个地址发送数据时，数据包会在本地计算机内部循环，而不会离开本机。这个地址范围主要用于网络测试、开发和故障排查。
    
2.  私有地址：私有地址被保留用于在内部网络中使用，不会在公共互联网上路由。这些地址允许组织在其内部网络中自由分配 IP 地址，而不会与外部网络产生冲突。私有地址范围如下：
    
    -   10.0.0.0 到 10.255.255.255（10.0.0.0/8）
    -   172.16.0.0 到 172.31.255.255（172.16.0.0/12）
    -   192.168.0.0 到 192.168.255.255（192.168.0.0/16）
3.  APIPA 地址：APIPA（Automatic Private IP Addressing）地址范围是 169.254.0.0 到 169.254.255.255。当一台设备无法从 DHCP 服务器获取 IP 地址时，它会自动分配一个 APIPA 地址。这允许在没有 DHCP 服务器的情况下进行简单的网络通信。然而，这些地址只能在本地子网内使用，不能用于互联网通信。
    
4.  多播地址：多播地址范围是 224.0.0.0 到 239.255.255.255，属于 D 类地址。多播地址用于将数据包发送到多个接收者，而无需为每个接收者单独发送数据包。这种方式能降低网络负载。常见的多播地址有 224.0.0.1（所有主机地址）和 224.0.0.2（所有路由器地址）。
    
5.  广播地址：广播地址用于向网络中的所有设备发送数据包。一个子网的广播地址是该子网中的最后一个 IP 地址。例如，对于子网 192.168.1.0/24，广播地址是 192.168.1.255。发送到广播地址的数据包会被子网内的所有设备接收。
    
6.  链路本地地址：链路本地地址范围是 169.254.0.0 到 169.254.255.255。这个地址范围用于在没有配置的情况下进行节点间通信。当一台设备无法从 DHCP 服务器获取 IP 地址时，它会自动分配一个链路本地地址。这允许在没有 DHCP 服务器的情况下进行简单的网络通信。然而，这些地址只能在本地子网内使用，不能用于互联网通信。

7.  网络地址：在一个子网中，网络地址是子网的第一个 IP 地址。网络地址用于表示整个子网，而不是特定的设备。例如，在子网 192.168.1.0/24 中，192.168.1.0 就是网络地址。需要注意的是，网络地址不能分配给个别设备。
    
8.  保留地址：一些特定的 IP 地址或地址范围被保留用于特殊用途。例如，255.255.255.255 是一个有限广播地址，用于在本地网络中向所有设备发送广播消息。另一个例子是 0.0.0.0，它在某些情况下用于表示“任意地址”，例如，当一个 DHCP 客户端正在寻找服务器时，它会使用源地址 0.0.0.0 发送请求。
    

总之，特殊的 IPv4 地址范围为网络通信提供了灵活性和多样性。了解这些地址范围及其用途对于网络管理、故障排除和网络编程等领域非常重要。



### 集线器 hub 与 交换机 的区别
1. 集线器是半双工的，会导致大量不必要的通信
2. 交换机则是全双工的，将数据发送到指定计算机的目标端口上

## TTL
ttl有一个很重要的用途就是获取沿途各种服务器的信息，主叫方每次给ttl增加1，便可以获得ICMP超时报文，于是便可以依次获得所有的网关地址，但许多配置了防火墙的路由器并不会这么做，基于udp数据包的traceroute也可能因为主机根本就没有提供udp服务而被直接丢弃，当然这可以通过将目标端口号修改为30000以上的数字来实现，这样的话就可以获得一个“端口不可达”的报文，当然也可以直接使用tcp

## ring buffer

环形缓冲区（Ring Buffer），也称为循环缓冲区、圆形缓冲区或循环队列，是一种数据结构，用于在没有重新分配内存或覆盖数据的情况下高效地存储和管理固定大小的数据。环形缓冲区的主要特点是当它被填满后，再插入新数据时，会覆盖最早插入的数据。环形缓冲区通常用于实现数据流处理、操作系统内核、网络协议栈等场景。

环形缓冲区的工作原理如下：

1.  **初始化**：创建一个固定大小的数组和两个指针（或索引），一个用于表示读（read）位置，另一个用于表示写（write）位置。初始时，读写位置相同，表示缓冲区为空。
    
2.  **写入数据**：当需要向缓冲区写入数据时，首先检查缓冲区是否已满。如果缓冲区未满（即写指针与读指针不相邻），则将数据写入写指针当前指向的位置，并将写指针向前移动一个位置。如果写指针到达数组末尾，则将其移动到数组起始位置，形成环形结构。如果缓冲区已满，根据需求可以选择丢弃新数据、覆盖旧数据或等待缓冲区有空闲空间。
    
3.  **读取数据**：当需要从缓冲区读取数据时，首先检查缓冲区是否为空。如果缓冲区不为空（即读写指针不相等），则从读指针当前指向的位置读取数据，并将读指针向前移动一个位置。如果读指针到达数组末尾，则将其移动到数组起始位置。如果缓冲区为空，可以选择等待缓冲区有数据或返回错误。
    
4.  **缓冲区满和空的判断**：通常，我们使用以下方法判断缓冲区是否为空或已满：
    
    -   如果读写指针相等，则缓冲区为空。
    -   如果写指针紧邻读指针（写指针位于读指针前一个位置），则缓冲区已满。
    
    也可以使用一个额外的计数器来跟踪缓冲区中的元素数量，以便更直接地判断缓冲区的状态。
    

环形缓冲区的优点包括：

-   高效地利用内存空间：环形缓冲区只需要固定大小的内存，不需要动态分配或释放内存。
-   高效的数据访问：读写操作通常仅涉及指针或索引的移动，具有较低的计算开销。