## 事件处理模式

### Reactor模式

Reactor 模式是一种基于事件驱动的设计模式，它用于处理并发 I/O 请求。在此模式中，事件处理器（Event Handler）负责处理特定类型的 I/O 事件（例如读取、写入、接受连接等），而 Reactor 负责管理这些事件处理器。Reactor 的核心是 I/O 多路复用器（例如 select、poll 或 epoll），它可以同时监视多个 I/O 描述符以检测它们的状态。

Reactor 模式的主要组件和步骤如下：

-   **事件处理器（Event Handler）**：处理特定类型的 I/O 事件。
-   **Reactor**：监视 I/O 描述符的状态并将相应的事件分派给相应的事件处理器。
-   **I/O 多路复用器**：允许 Reactor 同时监视多个 I/O 描述符。

Reactor 模式的工作流程：

1.  初始化 I/O 多路复用器和注册事件处理器。
2.  Reactor 使用 I/O 多路复用器监视 I/O 事件。
3.  当 I/O 事件发生时，I/O 多路复用器将其通知给 Reactor。
4.  Reactor 将事件分派给相应的事件处理器。
5.  事件处理器处理 I/O 事件，并将结果返回给 Reactor。
6.  如果需要，Reactor 更新 I/O 多路复用器中的 I/O 描述符状态。
7.  回到步骤 2，继续监视 I/O 事件。

Reactor 模式的优点：

-   可扩展性：Reactor 模式可以处理大量并发连接，因为它可以在单个线程中有效地监视和处理 I/O 事件。
-   解耦：事件处理器和 Reactor 之间的解耦使得代码更易于维护和扩展。

Reactor 模式的缺点：

-   同步 I/O：Reactor 模式依赖于同步 I/O 操作，这可能会导致阻塞和性能瓶颈。

## Proactor模式

Proactor 模式是另一种事件处理模式，它使用异步 I/O 操作（例如异步读取、写入和接受连接）来处理并发请求。在此模式中，服务器预先发起 I/O 操作并继续执行其他任务。当 I/O 操作完成时，Proactor 将收到通知并调用相应的事件处理器。

Proactor 模式的主要组件和步骤如下：

-   **事件处理器（Event Handler）**：处理特定类型的 I/O 事件。

-   **Proactor**：负责发起异步 I/O 操作并在操作完成时调用相应的事件处理器。
-   **异步 I/O 操作**：允许服务器在等待 I/O 完成时执行其他任务。

Proactor 模式的工作流程：

1.  初始化异步 I/O 操作和注册事件处理器。
2.  Proactor 发起异步 I/O 操作。
3.  服务器在等待 I/O 操作完成时执行其他任务。
4.  当 I/O 操作完成时，Proactor 收到通知。
5.  Proactor 将事件分派给相应的事件处理器。
6.  事件处理器处理 I/O 事件，并将结果返回给 Proactor。
7.  如果需要，Proactor 会发起更多的异步 I/O 操作。
8.  回到步骤 3，继续执行其他任务。

Proactor 模式的优点：

-   异步 I/O：Proactor 模式使用异步 I/O 操作，这避免了阻塞和性能瓶颈，从而提高了服务器的吞吐量。
-   可扩展性：与 Reactor 模式一样，Proactor 模式可以处理大量并发连接。

Proactor 模式的缺点：

-   复杂性：异步 I/O 操作和回调机制使 Proactor 模式比 Reactor 模式更复杂，可能导致代码难以维护和调试。

总结：

Reactor 和 Proactor 是两种不同的事件处理模式，它们分别基于同步 I/O 和异步 I/O 操作。Reactor 模式使用 I/O 多路复用器来监视和处理 I/O 事件，而 Proactor 模式则预先发起异步 I/O 操作并在操作完成时调用相应的事件处理器。这两种模式都可以有效地处理大量并发连接，但它们在实现复杂性和性能方面存在差异。选择哪种模式取决于应用程序的需求和平台支持。

-   Reactor模式：要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。
-   Proactor模式：将所有的I/O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑，如主线程读完成后`users[sockfd].read()`，选择一个工作线程来处理客户请求`pool->append(users + sockfd)`。

通常使用同步I/O模型（如`epoll_wait`）实现Reactor，使用异步I/O（如`aio_read`和`aio_write`）实现Proactor。

## I/O 复用

-   同步（阻塞）I/O：在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。
-   异步（非阻塞）I/O：当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。

Linux下有三种IO复用方式：epoll，select和poll

-   对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。
-   select使用线性表描述文件描述符集合，文件描述符有上限；poll使用链表来描述；epoll底层通过红黑树来描述，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。
-   select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。
-   select和poll都只能工作在相对低效的LT模式下，而epoll同时支持LT和ET模式。
-   综上，当监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll；当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。

## Epoll

### 两种触发模式

-   LT（电平触发）：类似`select`，LT会去遍历在epoll事件表中每个文件描述符，来观察是否有我们感兴趣的事件发生，如果有（触发了该文件描述符上的回调函数），`epoll_wait`就会以非阻塞的方式返回。若该epoll事件没有被处理完（没有返回`EWOULDBLOCK`），该事件还会被后续的`epoll_wait`再次触发。
-   ET（边缘触发）：ET在发现有我们感兴趣的事件发生后，立即返回，并且`sleep`这一事件的`epoll_wait`，不管该事件有没有结束。

在使用ET模式时，必须要保证该文件描述符是非阻塞的（确保在没有数据可读时，该文件描述符不会一直阻塞）；并且每次调用`read`和`write`的时候都必须等到它们返回`EWOULDBLOCK`（确保所有数据都已读完或写完）

1.  边缘触发（Edge-triggered）

边缘触发关注的是事件状态的改变。当某个I/O操作从不可进行变为可进行时，边缘触发的事件处理机制会通知相关事件。一旦通知发出，除非有新的状态改变，否则不会再次收到通知。

例如，当某个套接字从不可读状态变为可读状态时，边缘触发机制会发出通知。在接收到通知后，您需要一直读取数据，直到所有数据都被读取完毕（即再次不可读）。在这个过程中，边缘触发不会再次通知您，即使仍有数据可读。您需要自行保证将所有可用数据读取完毕，否则可能错过数据。

边缘触发的优点在于它只关注状态改变，因此减少了不必要的事件通知。这使得它在处理大量并发连接时更加高效。然而，边缘触发也增加了编程的复杂性，需要更多的注意力来确保正确处理所有数据。

2.  水平触发（Level-triggered）

水平触发关注的是事件的当前状态。只要某个I/O操作可进行，水平触发的事件处理机制就会持续通知相关事件，而不仅仅是在状态改变时通知一次。

例如，当某个套接字可读时，水平触发机制会不断发出通知，直到您读取了所有数据。如果在处理一个通知时，没有将所有数据读取完毕，那么在下一次事件循环时，您仍会收到关于可读数据的通知。

水平触发编程相对简单，因为它会持续通知您关于事件的状态，降低了漏掉数据的风险。然而，由于它会持续发出通知，这可能会导致更多的系统开销，特别是在处理大量并发连接时。

总结：

-   边缘触发关注事件状态的改变，通知发生在状态改变时。它在处理大量并发连接时更加高效，但编程复杂性较高。
-   水平触发关注事件的当前状态，只要条件满足，就会持续发出通知。编程相对简单，但在处理大量并发连接时可能导致更多的系统开销。

## 三类事件

### I/O事件

### 信号事件

### 定时事件


