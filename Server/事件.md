## 事件处理模式

### Reactor模式

Reactor 模式是一种基于事件驱动的设计模式，它用于处理并发 I/O 请求。在此模式中，事件处理器（Event Handler）负责处理特定类型的 I/O 事件（例如读取、写入、接受连接等），而 Reactor 负责管理这些事件处理器。Reactor 的核心是 I/O 多路复用器（例如 select、poll 或 epoll），它可以同时监视多个 I/O 描述符以检测它们的状态。

Reactor 模式的主要组件和步骤如下：

-   **事件处理器（Event Handler）**：处理特定类型的 I/O 事件。
-   **Reactor**：监视 I/O 描述符的状态并将相应的事件分派给相应的事件处理器。
-   **I/O 多路复用器**：允许 Reactor 同时监视多个 I/O 描述符。

Reactor 模式的工作流程：

1.  初始化 I/O 多路复用器和注册事件处理器。
2.  Reactor 使用 I/O 多路复用器监视 I/O 事件。
3.  当 I/O 事件发生时，I/O 多路复用器将其通知给 Reactor。
4.  Reactor 将事件分派给相应的事件处理器。
5.  事件处理器处理 I/O 事件，并将结果返回给 Reactor。
6.  如果需要，Reactor 更新 I/O 多路复用器中的 I/O 描述符状态。
7.  回到步骤 2，继续监视 I/O 事件。

Reactor 模式的优点：

-   可扩展性：Reactor 模式可以处理大量并发连接，因为它可以在单个线程中有效地监视和处理 I/O 事件。
-   解耦：事件处理器和 Reactor 之间的解耦使得代码更易于维护和扩展。

Reactor 模式的缺点：

-   同步 I/O：Reactor 模式依赖于同步 I/O 操作，这可能会导致阻塞和性能瓶颈。

## Proactor模式

Proactor 模式是另一种事件处理模式，它使用异步 I/O 操作（例如异步读取、写入和接受连接）来处理并发请求。在此模式中，服务器预先发起 I/O 操作并继续执行其他任务。当 I/O 操作完成时，Proactor 将收到通知并调用相应的事件处理器。

Proactor 模式的主要组件和步骤如下：

-   **事件处理器（Event Handler）**：处理特定类型的 I/O 事件。

-   **Proactor**：负责发起异步 I/O 操作并在操作完成时调用相应的事件处理器。
-   **异步 I/O 操作**：允许服务器在等待 I/O 完成时执行其他任务。

Proactor 模式的工作流程：

1.  初始化异步 I/O 操作和注册事件处理器。
2.  Proactor 发起异步 I/O 操作。
3.  服务器在等待 I/O 操作完成时执行其他任务。
4.  当 I/O 操作完成时，Proactor 收到通知。
5.  Proactor 将事件分派给相应的事件处理器。
6.  事件处理器处理 I/O 事件，并将结果返回给 Proactor。
7.  如果需要，Proactor 会发起更多的异步 I/O 操作。
8.  回到步骤 3，继续执行其他任务。

Proactor 模式的优点：

-   异步 I/O：Proactor 模式使用异步 I/O 操作，这避免了阻塞和性能瓶颈，从而提高了服务器的吞吐量。
-   可扩展性：与 Reactor 模式一样，Proactor 模式可以处理大量并发连接。

Proactor 模式的缺点：

-   复杂性：异步 I/O 操作和回调机制使 Proactor 模式比 Reactor 模式更复杂，可能导致代码难以维护和调试。

总结：

Reactor 和 Proactor 是两种不同的事件处理模式，它们分别基于同步 I/O 和异步 I/O 操作。Reactor 模式使用 I/O 多路复用器来监视和处理 I/O 事件，而 Proactor 模式则预先发起异步 I/O 操作并在操作完成时调用相应的事件处理器。这两种模式都可以有效地处理大量并发连接，但它们在实现复杂性和性能方面存在差异。选择哪种模式取决于应用程序的需求和平台支持。

-   Reactor模式：要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。
-   Proactor模式：将所有的I/O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑，如主线程读完成后`users[sockfd].read()`，选择一个工作线程来处理客户请求`pool->append(users + sockfd)`。

通常使用同步I/O模型（如`epoll_wait`）实现Reactor，使用异步I/O（如`aio_read`和`aio_write`）实现Proactor。

## I/O 复用

-   同步（阻塞）I/O：在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。
-   异步（非阻塞）I/O：当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。

Linux下有三种IO复用方式：epoll，select和poll

## 三类事件

### I/O事件

### 信号事件

### 定时事件


